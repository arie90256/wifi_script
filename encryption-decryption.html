<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Symbol-Based Encryption with File Support</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            overflow-y: auto;
            background-color: black;
            color: #00ff00;
        }

        textarea, button, input[type="file"], input[type="text"], input[type="password"] {
            margin: 10px 0;
            padding: 10px;
            width: 100%;
            max-width: 600px;
            border: 1px solid #00ff00;
            background-color: black;
            color: #00ff00;
            font-family: Arial, sans-serif;
        }

        textarea {
            height: 200px;
            resize: none;
        }

        button {
            cursor: pointer;
        }

        button:hover {
            background-color: #0056b3;
        }

        .button-group {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
        }

        /* Canvas for Matrix Rain */
        #matrixCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 250%;
            z-index: -1; /* Behind other content */
        }

        /* Loading Indicator */
        #loadingIndicator {
            display: none;
            text-align: center;
            margin: 20px;
        }

        .spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #00ff00;
            border-radius: 50%;
            border-top-color: transparent;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body oncontextmenu="return false;"> <!-- Disable right-click -->
    <canvas id="matrixCanvas" role="presentation"></canvas>
    <h1>Symbol-Based Encryption with File Support</h1>

    <!-- Loading Indicator -->
    <div id="loadingIndicator" role="alert" aria-live="assertive">
        <span>Loading...</span>
        <div class="spinner" aria-hidden="true"></div>
    </div>

    <!-- Encryption Section -->
    <h2>Encrypt Text</h2>
    <textarea id="inputText" placeholder="Enter text to encrypt" aria-label="Input text for encryption"></textarea>
    <input type="password" id="encryptionPassword" placeholder="Enter password for encryption" aria-label="Password for encryption">
    <div class="button-group">
        <button onclick="handleEncrypt()" aria-label="Encrypt the input text">Encrypt</button>
        <button onclick="handleLoadForEncryption()" aria-label="Load files for encryption">Load Files for Encryption</button>
    </div>

    <!-- Encrypted Output Section -->
    <h2>Encrypted Text</h2>
    <textarea id="outputText" placeholder="Encrypted text will appear here" aria-label="Output encrypted text"></textarea>
    <input type="text" id="encryptedFileName" placeholder="Enter name for encrypted file (default: encrypted.txt)" aria-label="Filename for encrypted text">
    <div class="button-group">
        <button onclick="handleSaveEncrypted()" aria-label="Save the encrypted text to a file">Save Encrypted Text</button>
    </div>

    <!-- Decryption Section -->
    <h2>Decrypt Text</h2>
    <textarea id="decryptedText" placeholder="Decrypted text will appear here" aria-label="Output decrypted text"></textarea>
    <input type="password" id="decryptionPassword" placeholder="Enter password for decryption" aria-label="Password for decryption">
    <input type="text" id="decryptedFileName" placeholder="Enter name for decrypted file (default: decrypted.txt)" aria-label="Filename for decrypted text">
    <div class="button-group">
        <button onclick="handleDecrypt()" aria-label="Decrypt the encrypted text">Decrypt</button>
        <button onclick="handleLoadForDecryption()" aria-label="Load files for decryption">Load Files for Decryption</button>
        <button onclick="handleSaveDecrypted()" aria-label="Save the decrypted text to a file">Save Decrypted Text</button>
    </div>

    <!-- Reset Button -->
    <div class="button-group">
        <button onclick="handleReset()" aria-label="Reset all fields">Reset</button>
    </div>
    <!-- Logout Button -->
    <div class="button-group">
        <button onclick="handleLogout()" aria-label="Logout and redirect to login page">Logout</button>
    </div>

    <script>
        function handleLogout() {
            window.location.href = "login offline.html";
        }

        // Predefined Mapping for Encryption/Decryption add in your own symbol maping. 
        const predefinedSymbolMap = {
            // Lowercase letters
            'a': 'ア', 
            // Uppercase letters
            'A': 'ヒ', 
            // Numbers
            '0': '零',
            // Punctuation
            '.': '点',
            // Whitespaces
            ' ': 'Ψ',
        };

        const reversePredefinedSymbolMap = Object.fromEntries(
            Object.entries(predefinedSymbolMap).map(([key, value]) => [value, key])
        );

        function encryptWithPredefinedMap(input) {
            return input.split('').map(char => predefinedSymbolMap[char] || char).join('');
        }

        function decryptWithPredefinedMap(input) {
            return input.split('').map(char => reversePredefinedSymbolMap[char] || char).join('');
        }

        function handleEncrypt() {
            const inputText = document.getElementById('inputText').value;
            const password = document.getElementById('encryptionPassword').value;

            if (!inputText || !password) {
                alert('Enter both text and password to encrypt.');
                return;
            }

            const encrypted = encryptWithPredefinedMap(inputText + password);
            document.getElementById('outputText').value = encrypted;
        }

        function handleDecrypt() {
            const encryptedText = document.getElementById('outputText').value;
            const password = document.getElementById('decryptionPassword').value;

            if (!encryptedText || !password) {
                alert('Enter both encrypted text and password to decrypt.');
                return;
            }

            const decrypted = decryptWithPredefinedMap(encryptedText);
            if (!decrypted.endsWith(password)) {
                alert('Incorrect password.');
                return;
            }

            const originalText = decrypted.slice(0, -password.length);
            document.getElementById('decryptedText').value = originalText;
        }

        function handleReset() {
            document.getElementById('inputText').value = '';
            document.getElementById('outputText').value = '';
            document.getElementById('decryptedText').value = '';
            document.getElementById('encryptionPassword').value = '';
            document.getElementById('decryptionPassword').value = '';
            document.getElementById('encryptedFileName').value = '';
            document.getElementById('decryptedFileName').value = '';
        }

        // Function to save content to a file
        function saveToFile(content, fileName) {
            const blob = new Blob([content], { type: 'text/plain' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = fileName;
            document.body.appendChild(link); // Append link to body
            link.click(); // Trigger download
            document.body.removeChild(link); // Remove link after download
        }

        // Function to load files and execute a callback with file contents
        function loadFiles(callback) {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.txt';
            input.multiple = true; // Allow multiple file selection

            input.onchange = (event) => {
                const files = event.target.files;
                const fileContents = [];
                let filesProcessed = 0;

                if (files.length === 0) {
                    alert('No files selected. Please select at least one file.');
                    return;
                }

                // Show loading indicator
                document.getElementById('loadingIndicator').style.display = 'block';

                for (let i = 0; i < files.length; i++) {
                    const file = files[i];
                    const reader = new FileReader();
                    reader.onload = () => {
                        fileContents.push(reader.result);
                        filesProcessed++;
                        // Once all files are processed, call the callback
                        if (filesProcessed === files.length) {
                            document.getElementById('loadingIndicator').style.display = 'none'; // Hide loading indicator
                            callback(fileContents);
                        }
                    };
                    reader.onerror = () => {
                        alert(`Error reading file: ${file.name}. Please try again.`);
                        document.getElementById('loadingIndicator').style.display = 'none';
                    };
                    reader.readAsText(file);
                }
            };

            input.click();
        }

        // Load files for encryption
        function handleLoadForEncryption() {
            loadFiles((fileContents) => {
                try {
                    const password = document.getElementById('encryptionPassword').value.trim();
                    if (!password) {
                        alert('Please enter a password for encryption.');
                        return;
                    }
                    const encryptedContents = fileContents.map(content => encryptWithPredefinedMap(content + password)).join('\n');
                    document.getElementById('outputText').value = encryptedContents;
                } catch (error) {
                    console.error('Error during file encryption:', error);
                    alert('An error occurred while encrypting the loaded files. Please try again.');
                }
            });
        }

        // Load files for decryption
        function handleLoadForDecryption() {
            loadFiles((fileContents) => {
                try {
                    const password = document.getElementById('decryptionPassword').value.trim();
                    if (!password) {
                        alert('Please enter a password for decryption.');
                        return;
                    }
                    const decryptedContents = fileContents.map(content => {
                        const decryptedWithPassword = decryptWithPredefinedMap(content);
                        if (!decryptedWithPassword.endsWith(password)) {
                            throw new Error('Decryption failed for one or more files due to incorrect password.');
                        }
                        return decryptedWithPassword.slice(0, -password.length);
                    }).join('\n');
                    document.getElementById('decryptedText').value = decryptedContents;
                } catch (error) {
                    console.error('Error during file decryption:', error);
                    alert('An error occurred while decrypting the loaded files. Please try again.');
                }
            });
        }

        // Save encrypted text to a file
        function handleSaveEncrypted() {
            const encryptedText = document.getElementById('outputText').value.trim();
            const fileName = document.getElementById('encryptedFileName').value.trim() || 'encrypted.txt';

            if (!encryptedText) {
                alert('No encrypted text to save.');
                return;
            }

            saveToFile(encryptedText, fileName);
        }

        // Save decrypted text to a file
        function handleSaveDecrypted() {
            const decryptedText = document.getElementById('decryptedText').value.trim();
            const fileName = document.getElementById('decryptedFileName').value.trim() || 'decrypted.txt';

            if (!decryptedText) {
                alert('No decrypted text to save.');
                return;
            }

            saveToFile(decryptedText, fileName);
        }

        // Matrix Rain Effect
        const canvas = document.getElementById('matrixCanvas');
        const ctx = canvas.getContext('2d');
        canvas.height = window.innerHeight;
        canvas.width = window.innerWidth;

        const characters = 'ア#リウエオ1カキク+ケコサシスセソ-タチツテ0トナニヌネノハ+ヒフヘホ0マミムメモヤ-ユヨワン漢1字平0';
        const fontSize = 16;
        const columns = canvas.width / fontSize;
        const drops = Array(Math.floor(columns)).fill(1);

        function draw() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.05)'; // Background with slight transparency
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#00ff00'; // Text color
            ctx.font = fontSize + 'px monospace';

            for (let i = 0; i < drops.length; i++) {
                const text = characters[Math.floor(Math.random() * characters.length)];
                ctx.fillText(text, i * fontSize, drops[i] * fontSize);
                if (drops[i] * fontSize > canvas.height && Math.random() > 0.975) {
                    drops[i] = 0; // Reset drop to the top
                }
                drops[i]++;
            }
        }

        setInterval(draw, 33); // Draw every 33 milliseconds

        window.addEventListener('resize', () => {
            canvas.height = window.innerHeight;
            canvas.width = window.innerWidth;
            const columns = Math.floor(canvas.width / fontSize);
            drops.length = columns;
            for (let i = 0; i < columns; i++) {
                drops[i] = Math.random() * canvas.height / fontSize;
            }
        });
    </script>
</body>
</html>

