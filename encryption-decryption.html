<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Symbol-Based Encryption with File Support</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            overflow-y: auto;
            background-color: black;
            color: #00ff00;
        }

        textarea, button, input[type="file"], input[type="text"], input[type="password"] {
            margin: 10px 0;
            padding: 10px;
            width: 100%;
            max-width: 600px;
            border: 1px solid #00ff00;
            background-color: black;
            color: #00ff00;
            font-family: Arial, sans-serif;
        }

        textarea {
            height: 200px;
            resize: none;
        }

        button {
            cursor: pointer;
        }

        button:hover {
            background-color: #0056b3;
        }

        .button-group {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
        }

        /* Canvas for Matrix Rain */
        #matrixCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 200%;
            z-index: -1; /* Behind other content */
        }

        /* Loading Indicator */
        #loadingIndicator {
            display: none;
            text-align: center;
            margin: 20px;
        }

        .spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #00ff00;
            border-radius: 50%;
            border-top-color: transparent;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.0.0/crypto-js.min.js"></script>
</head>
<body oncontextmenu="return false;"> <!-- Disable right-click -->
    <canvas id="matrixCanvas" role="presentation"></canvas>
    <h1>Symbol-Based Encryption with File Support</h1>

    <!-- Loading Indicator -->
    <div id="loadingIndicator" role="alert" aria-live="assertive">
        <span>Loading...</span>
        <div class="spinner" aria-hidden="true"></div>
    </div>

    <!-- Encryption Section -->
    <h2>Encrypt Text</h2>
    <textarea id="inputText" placeholder="Enter text to encrypt" aria-label="Input text for encryption"></textarea>
    <input type="password" id="encryptionPassword" placeholder="Enter password for encryption" aria-label="Password for encryption">
    <div class="button-group">
        <button onclick="handleEncrypt()" aria-label="Encrypt the input text">Encrypt</button>
        <button onclick="handleLoadForEncryption()" aria-label="Load files for encryption">Load Files for Encryption</button>
    </div>

    <!-- Encrypted Output Section -->
    <h2>Encrypted Text</h2>
    <textarea id="outputText" placeholder="Encrypted text will appear here" aria-label="Output encrypted text"></textarea>
    <input type="text" id="encryptedFileName" placeholder="Enter name for encrypted file (default: encrypted.txt)" aria-label="Filename for encrypted text">
    <div class="button-group">
        <button onclick="handleSaveEncrypted()" aria-label="Save the encrypted text to a file">Save Encrypted Text</button>
    </div>

    <!-- Decryption Section -->
    <h2>Decrypt Text</h2>
    <textarea id="decryptedText" placeholder="Decrypted text will appear here" aria-label="Output decrypted text"></textarea>
    <input type="password" id="decryptionPassword" placeholder="Enter password for decryption" aria-label="Password for decryption">
    <input type="text" id="decryptedFileName" placeholder="Enter name for decrypted file (default: decrypted.txt)" aria-label="Filename for decrypted text">
    <div class="button-group">
        <button onclick="handleDecrypt()" aria-label="Decrypt the encrypted text">Decrypt</button>
        <button onclick="handleLoadForDecryption()" aria-label="Load files for decryption">Load Files for Decryption</button>
                <button onclick="handleSaveDecrypted()" aria-label="Save the decrypted text to a file">Save Decrypted Text</button>
    </div>

    <!-- Reset Button -->
    <div class="button-group">
        <button onclick="handleReset()" aria-label="Reset all fields">Reset</button>
    </div>

    <script>
        // Predefined Mapping for Encryption/Decryption
        const predefinedSymbolMap = {
            // Lowercase letters
            'a': 'ア', 
            'b': 'リ', 
            'c': 'ウ', 
            'd': 'エ', 
            'e': 'オ',
            'f': 'カ', 
            'g': 'キ', 
            'h': 'ク', 
            'i': 'ケ', 
            'j': 'コ',
            'k': 'サ', 
            'l': 'シ', 
            'm': 'ス', 
            'n': 'セ', 
            'o': 'ソ',
            'p': 'タ', 
            'q': 'チ', 
            'r': 'ツ', 
            's': 'テ', 
            't': 'ト',
            'u': 'ナ', 
            'v': 'ニ', 
            'w': 'ヌ', 
            'x': 'ネ', 
            'y': 'ノ',
            'z': 'ハ',

            // Uppercase letters
            'A': 'ヒ', 
            'B': 'フ', 
            'C': 'ヘ', 
            'D': 'ホ', 
            'E': 'マ',
            'F': 'ミ', 
            'G': 'ム', 
            'H': 'メ', 
            'I': 'モ', 
            'J': 'ヤ',
            'K': 'ユ', 
            'L': 'ヨ', 
            'M': 'ワ', 
            'N': 'ン', 
            'O': '漢',
            'P': '字', 
            'Q': '平', 
            'R': '片', 
            'S': '仮', 
            'T': 'ヴ',
            'U': '中', 
            'V': '国', 
            'W': '語', 
            'X': '日', 
            'Y': '一',
            'Z': '本',

            // Numbers
            '0': '零', 
            '1': '壱', 
            '2': '弐', 
            '3': '参', 
            '4': '四',
            '5': '五', 
            '6': '六', 
            '7': '七', 
            '8': '八', 
            '9': '九',

            // Punctuation
            '.': '点', 
            ',': '逗', 
            '?': '？', 
            '!': '！', 
            ':': '：',
            ';': '；', 
            '\'': '’', 
            '"': '”', 
            '(': '（', 
            ')': '）',
            '[': '［', 
            ']': '］', 
            '{': '｛', 
            '}': '｝', 
            '<': '＜',
            '>': '＞', 
            '/': '／', 
            '\\': '＼', 
            '&': '＆', 
            '|': '｜',
            '-': 'ー', 
            '_': '＿', 
            '+': '＋', 
            '=': '＝', 
            '`': '｀',
            '~': '～', 
            '@': '＠', 
            '#': '＃', 
            '$': '＄', 
            '%': '%',
            '^': '＾', 
            '*': '＊', 
            '…': '省', 
            '—': '破',

            // Whitespaces
            ' ': '　', 
            '\n': '改', 
            '\t': '横'
        };

        const reversePredefinedSymbolMap = Object.fromEntries(
            Object.entries(predefinedSymbolMap).map(([key, value]) => [value, key])
        );

        // Encryption Function
        function encryptWithPredefinedMap(input, password) {
            const encryptedText = CryptoJS.AES.encrypt(input, password).toString();
            return encryptedText;
        }

        // Decryption Function
        function decryptWithPredefinedMap(input, password) {
            const decryptedBytes = CryptoJS.AES.decrypt(input, password);
                        const decryptedText = decryptedBytes.toString(CryptoJS.enc.Utf8);
            return decryptedText;
        }

        // File Save Function
        function saveToFile(content, filename) {
            const blob = new Blob([content], { type: 'text/plain' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = filename;
            document.body.appendChild(link); // Append link to body
            link.click(); // Simulate click to trigger download
            document.body.removeChild(link); // Remove link after download
        }

        // File Load Function for Multiple Files
        function loadFiles(callback) {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.txt';
            input.multiple = true; // Allow multiple file selection

            input.onchange = (event) => {
                const files = event.target.files;
                const fileContents = [];
                let filesProcessed = 0;

                if (files.length === 0) {
                    alert('No files selected. Please select at least one file.');
                    return;
                }

                // Show loading indicator
                document.getElementById('loadingIndicator').style.display = 'block';

                for (let i = 0; i < files.length; i++) {
                    const file = files[i];
                    const reader = new FileReader();
                    reader.onload = () => {
                        fileContents.push(reader.result);
                        filesProcessed++;
                        // Once all files are processed, call the callback
                        if (filesProcessed === files.length) {
                            // Hide loading indicator
                            document.getElementById('loadingIndicator').style.display = 'none';
                            callback(fileContents);
                        }
                    };
                    reader.onerror = () => {
                        alert(`Error reading file: ${file.name}. Please try again.`);
                        // Hide loading indicator in case of error
                        document.getElementById('loadingIndicator').style.display = 'none';
                    };
                    reader.readAsText(file);
                }
            };

            input.click();
        }

        // Button Handlers
        function handleEncrypt() {
            try {
                const inputText = document.getElementById('inputText').value;
                const password = document.getElementById('encryptionPassword').value;
                if (!inputText) {
                    alert('Please enter text to encrypt.');
                    return;
                }
                const encrypted = encryptWithPredefinedMap(inputText, password);
                document.getElementById('outputText').value = encrypted;
            } catch (error) {
                console.error('Encryption error:', error);
                alert('An error occurred during encryption. Please try again.');
            }
        }

        function handleDecrypt() {
            try {
                const encryptedText = document.getElementById('outputText').value;
                const password = document.getElementById('decryptionPassword').value;
                if (!encryptedText) {
                    alert('Please enter text to decrypt.');
                    return;
                }
                const decrypted = decryptWithPredefinedMap(encryptedText, password);
                if (!decrypted) {
                    alert('Decryption failed. Please check your password.');
                    return;
                }
                document.getElementById('decryptedText').value = decrypted;
            } catch (error) {
                console.error('Decryption error:', error);
                alert('An error occurred during decryption. Please try again.');
            }
        }

        function handleSaveEncrypted() {
            try {
                const encryptedText = document.getElementById('outputText').value;
                const fileName = document.getElementById('encryptedFileName').value.trim() || 'encrypted.txt';
                if (!encryptedText) {
                    alert('No encrypted text to save.');
                    return;
                }
                saveToFile(encryptedText, fileName);
            } catch (error) {
                console.error('Error saving encrypted text:', error);
                alert('An error occurred while saving the encrypted text. Please try again.');
            }
        }

        function handleSaveDecrypted() {
            try {
                const decryptedText = document.getElementById('decryptedText').value;
                const fileName = document.getElementById('decryptedFileName').value.trim() || 'decrypted.txt';
                if (!decryptedText) {
                    alert('No decrypted text to save.');
                    return;
                }
                saveToFile(decryptedText, fileName);
            } catch (error) {
                console.error('Error saving decrypted text:', error);
                alert('An error occurred while saving the decrypted text. Please try again.');
            }
        }

        function handleLoadForEncryption() {
            document.getElementById('loadingIndicator').style.display = 'block'; // Show loading indicator
            loadFiles((fileContents) => {
                try {
                                        const encryptedContents = fileContents.map(content => encryptWithPredefinedMap(content, document.getElementById('encryptionPassword').value)).join('\n');
                    document.getElementById('outputText').value = encryptedContents;
                } catch (error) {
                    console.error('Error during file encryption:', error);
                    alert('An error occurred while encrypting the loaded files. Please try again.');
                } finally {
                    document.getElementById('loadingIndicator').style.display = 'none'; // Hide loading indicator
                }
            });
        }

        function handleLoadForDecryption() {
            document.getElementById('loadingIndicator').style.display = 'block'; // Show loading indicator
            loadFiles((fileContents) => {
                try {
                    const decryptedContents = fileContents.map(content => decryptWithPredefinedMap(content, document.getElementById('decryptionPassword').value)).join('\n');
                    document.getElementById('decryptedText').value = decryptedContents;
                } catch (error) {
                    console.error('Error during file decryption:', error);
                    alert('An error occurred while decrypting the loaded files. Please try again.');
                } finally {
                    document.getElementById('loadingIndicator').style.display = 'none'; // Hide loading indicator
                }
            });
        }

        // Reset Function
        function handleReset() {
            document.getElementById('inputText').value = '';
            document.getElementById('outputText').value = '';
            document.getElementById('decryptedText').value = '';
            document.getElementById('encryptionPassword').value = '';
            document.getElementById('decryptionPassword').value = '';
            document.getElementById('encryptedFileName').value = '';
            document.getElementById('decryptedFileName').value = '';
        }

        // Matrix Rain Effect
        const canvas = document.getElementById('matrixCanvas');
        const ctx = canvas.getContext('2d');
        canvas.height = window.innerHeight;
        canvas.width = window.innerWidth;

        const characters = 'ア#リウエオ1カキク+ケコサシスセソ-タチツテ0トナニヌネノハ+ヒフヘホ0マミムメモヤ-ユヨワン漢1字平0';
        const fontSize = 16;
        const columns = canvas.width / fontSize;
        const drops = Array(Math.floor(columns)).fill(1);

        function draw() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.05)'; // Background with slight transparency
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = '#00ff00'; // Text color
            ctx.font = fontSize + 'px monospace';

            for (let i = 0; i < drops.length; i++) {
                const text = characters[Math.floor(Math.random() * characters.length)];
                ctx.fillText(text, i * fontSize, drops[i] * fontSize);
                if (drops[i] * fontSize > canvas.height && Math.random() > 0.975) {
                    drops[i] = 0; // Reset drop to the top
                }
                drops[i]++;
            }
        }

        setInterval(draw, 33); // Draw every 33 milliseconds
        
        // Resize canvas on window resize
        window.addEventListener('resize', () => {
            canvas.height = window.innerHeight;
            canvas.width = window.innerWidth;
            const columns = Math.floor(canvas.width / fontSize);
            drops.length = columns; // Adjust drops array length
            for (let i = 0; i < columns; i++) {
                drops[i] = Math.random() * canvas.height / fontSize; // Randomize initial drop positions
            }
        });
    </script>
</body>
</html>
